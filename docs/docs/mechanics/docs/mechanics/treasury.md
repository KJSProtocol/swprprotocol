# Treasury Mechanics

The SwprTreasury contract receives all value generated by sweeps  
and allocates it according to fixed, transparent, on-chain rules.

The treasury is non-custodial, deterministic, and uses basis-point (BPS)  
allocations to split recovered value into meaningful buckets.

---

## ðŸ”µ Core Responsibilities

The treasury performs three primary functions:

1. **Receive** output tokens from successful sweeps  
2. **Allocate** those tokens across distinct distribution categories  
3. **Emit** events to allow dashboards/analytics to reflect activity  

It does *not* perform:

- Mixing of user balances  
- Lending or investing  
- Yield strategies  
- Governance logic  

Treasury design is kept intentionally simple and auditable.

---

## ðŸ”µ Value Allocation Model

All sweep output is split using percentage-based rules:

- **Founder allocation** â€” long-term incentive & protocol stewardship  
- **Reserve pool** â€” future protocol expansion, auditing, integrations  
- **Incentives** â€” future community/staker/bot incentives  

These are expressed in **basis points (BPS)**:  
- 10,000 BPS = 100%  
- 500 BPS = 5%  
- 1,000 BPS = 10%

Example:

These values are adjustable only by a restricted admin address  
and only within safe bounds defined at deployment.

---

## ðŸ”µ distribute() Function

Once the treasury receives tokens from a sweep, it allocates them:

```solidity
function distribute(address token) external {
    uint256 balance = IERC20(token).balanceOf(address(this));

    uint256 founderShare   = (balance * founderBps) / 10000;
    uint256 reserveShare   = (balance * reserveBps) / 10000;
    uint256 incentiveShare = balance - founderShare - reserveShare;

    IERC20(token).transfer(founder, founderShare);
    IERC20(token).transfer(reserve, reserveShare);
    IERC20(token).transfer(incentives, incentiveShare);

    emit ValueDistributed(token, founderShare, reserveShare, incentiveShare);
}

